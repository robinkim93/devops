# 📅 Day 1: strace로 시스템 콜 분석하기

## 🎯 오늘의 목표

> **토스플레이스 연결점**: "OS 레이어에서의 트러블슈팅 경험"

애플리케이션이 느리거나 장애가 발생했을 때, **strace**로 시스템 콜을 분석하여 원인을 찾을 수 있어야 합니다.

----

## ⏰ 예상 학습 시간: 3시간

| 구분 | 시간 | 내용 |
|------|------|------|
| 개념 | 30분 | 시스템 콜이란? |
| 실습 | 2시간 | strace 사용법 |
| 정리 | 30분 | 복습 및 체크리스트 |

---

## 📚 Part 1: 핵심 개념 (30분)

### 시스템 콜이란?

```
애플리케이션이 파일을 읽거나, 네트워크 통신을 하려면
→ 운영체제(커널)에게 "대신 해달라고" 요청해야 함
→ 이 요청을 "시스템 콜(System Call)"이라고 함
```

### 왜 DevOps 엔지니어가 알아야 하나?

```
┌─────────────────────────────────────────────────────────────┐
│  실제 장애 상황                                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  증상: "서버 CPU 100%인데 애플리케이션 로직은 한가해요"      │
│                                                             │
│  분석: strace -c -p <pid>                                   │
│                                                             │
│  결과:                                                      │
│    % time     seconds  calls      syscall                   │
│    ------  ----------- -----      --------                  │
│     89.12    0.891234  1500000    read     ← 문제 발견!     │
│      8.23    0.082345  1500000    open                      │
│      2.65    0.026543  1500000    close                     │
│                                                             │
│  진단: 작은 파일 150만 개를 개별적으로 열고 닫음             │
│  해결: 버퍼링 또는 배치 처리로 시스템 콜 횟수 감소           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 자주 보게 될 시스템 콜

| 시스템 콜 | 하는 일 | 장애 분석 시 의미 |
|----------|--------|-----------------|
| `read` | 파일/소켓에서 읽기 | I/O 병목 확인 |
| `write` | 파일/소켓에 쓰기 | 로그 출력, 응답 전송 |
| `open/openat` | 파일 열기 | 파일 접근 문제 |
| `close` | 파일 닫기 | 리소스 정리 |
| `connect` | 네트워크 연결 | DB/외부 API 연결 지연 |
| `poll/epoll` | I/O 대기 | 이벤트 대기 패턴 |

---

## 🛠️ Part 2: 실습 (2시간)

### 사전 준비

```bash
# Linux VM 접속 (Multipass, Docker 등)
# strace 설치 확인
which strace

# 없으면 설치
sudo apt update && sudo apt install -y strace
```

---

### 실습 1: 기본 사용법 (20분)

**목표**: `ls` 명령어가 어떤 시스템 콜을 사용하는지 확인

```bash
# ls 명령어의 모든 시스템 콜 출력
strace ls
```

**예상 출력 (주요 부분)**:
```
execve("/bin/ls", ["ls"], 0x7ffd...) = 0
...
openat(AT_FDCWD, ".", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3
getdents64(3, /* 5 entries */, 32768) = 152
getdents64(3, /* 0 entries */, 32768) = 0
close(3)                                = 0
write(1, "file1.txt\nfile2.txt\n", 20)  = 20
...
```

**분석 포인트**:
- `openat`: 현재 디렉토리(`.`)를 열음
- `getdents64`: 디렉토리 내용을 읽음
- `write`: 결과를 화면에 출력

---

### 실습 2: 시스템 콜 통계 확인 (20분)

**목표**: 어떤 시스템 콜이 가장 많이 호출되는지 확인

```bash
# -c 옵션: 통계만 출력
strace -c ls
```

**예상 출력**:
```
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 25.00    0.000012           6         2           read
 16.67    0.000008           4         2           write
 16.67    0.000008           2         4           close
 12.50    0.000006           2         3           openat
  8.33    0.000004           4         1           getdents64
...
------ ----------- ----------- --------- --------- ----------------
100.00    0.000048                    34         5 total
```

**분석 포인트**:
- `calls`: 해당 시스템 콜 호출 횟수
- `% time`: 전체 시간 중 비율
- `errors`: 실패 횟수 (0이 아니면 문제!)

---

### 실습 3: 소요 시간 측정 (30분)

**목표**: 각 시스템 콜이 얼마나 걸리는지 확인

```bash
# -T 옵션: 각 시스템 콜 소요 시간 표시
strace -T ls
```

**예상 출력**:
```
openat(AT_FDCWD, ".", ...) = 3 <0.000015>
getdents64(3, ...) = 152 <0.000025>
close(3) = 0 <0.000008>
write(1, "file1.txt\n", 10) = 10 <0.000012>
                                    ↑
                                소요시간 (초)
```

**분석 기준**:
- `<0.001>` 이상 (1ms): 주의
- `<0.1>` 이상 (100ms): 심각
- `<1.0>` 이상 (1초): 매우 심각

---

### 실습 4: 특정 시스템 콜만 필터링 (30분)

**목표**: 네트워크 관련 시스템 콜만 확인

```bash
# 네트워크 관련만 추적
strace -e trace=network curl -s https://google.com > /dev/null
```

**예상 출력**:
```
socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 5
connect(5, {sa_family=AF_INET, sin_port=htons(443), ...}, 16) = 0
...
```

**다른 필터 옵션**:
```bash
# 파일 관련만
strace -e trace=file ls

# 프로세스 관련만
strace -e trace=process bash -c "ls"

# 읽기/쓰기만
strace -e trace=read,write cat /etc/passwd
```

---

### 실습 5: 실행 중인 프로세스 분석 (20분)

**목표**: 실행 중인 프로세스에 strace 연결

```bash
# 1. 테스트용 프로세스 실행 (백그라운드)
sleep 1000 &

# 2. PID 확인
ps aux | grep sleep
# 예: 12345

# 3. 해당 프로세스에 strace 연결
sudo strace -p 12345

# 4. 종료: Ctrl+C
```

**토스플레이스 실무 상황**:
```bash
# 느린 Java 앱 분석
sudo strace -c -p $(pgrep java)

# 5초간 수집 후 Ctrl+C → 통계 확인
```

---

## 📊 Part 3: 장애 시나리오 실습 (선택)

### 시나리오: API 응답이 느린 원인 찾기

```bash
# 시뮬레이션: 느린 네트워크 요청
strace -T -e trace=network curl https://httpbin.org/delay/2
```

**확인할 것**:
- `connect()` 시스템 콜의 소요 시간
- 어느 단계에서 지연이 발생하는지

---

## ✅ 오늘의 체크리스트

완료하면 체크하세요:

| # | 항목 | 완료 |
|---|------|------|
| 1 | `strace ls` 실행하고 출력 이해함 | ☐ |
| 2 | `strace -c ls`로 통계 확인함 | ☐ |
| 3 | `strace -T`로 소요 시간 확인함 | ☐ |
| 4 | `strace -e trace=network`로 필터링함 | ☐ |
| 5 | 실행 중인 프로세스에 `strace -p` 연결함 | ☐ |

---

## 🔑 오늘 배운 핵심 명령어

```bash
# 반드시 외울 것!
strace <command>           # 기본 추적
strace -c <command>        # 통계만
strace -T <command>        # 소요시간 포함
strace -e trace=network    # 네트워크만
strace -e trace=file       # 파일만
strace -p <pid>            # 실행 중 프로세스
```

---

## 📝 학습 기록

```
학습일: 2026년 01월 08일
실제 소요 시간: 1시간 30분
```
[블로그 정리 링크](https://dev-robinkim-93.tistory.com/34)

---

## ➡️ 다음 학습: Day 2

**주제**: `/proc` 파일시스템으로 프로세스 상태 분석

**예고**:
- `/proc/[pid]/fd` - 열린 파일 확인
- `/proc/[pid]/status` - 메모리/스레드 확인
- FD 누수 탐지 방법

